I implemented Blitzball in python using the game engine pygame. This is a fairly simple gaming engine that is well-suited to two dimensional games, which was perfect for my pseudo-3d pixel art style.

I will now discuss the structure and layout of the blitzball.py file. First, I define all the colors, parameters, sprites, fonts, functions, etc. that will be useful in the game. Having all of these clearly defined and commented before the main game loop allows for easy customization of parameters controlling the game, which makes personalizing it quite achievable. In this preamble to the game loop, we also open the connection to the scores database, which creates the file and the highscores table within it if these do not exist.

After defining all these parameters, getting the game music playing (which I also made!) and defining sound effects and importing sprites for the bat and pitcher, the game loop is ready to begin. The way the game works is like this -- there are a variety of Boolean parameters that determine what game state the user is in. These parameters are username_stage, running, transition, and leader_stage. At first, all of these are false except for username_stage. In the while loop that defines the game, we first check to see if the user has quit the game, clicked or pressed a key. These inputs can have effects on the game state parameters -- for example, hitting the return key in the username stage with a non-null username sets username stage to false. Once the key presses are computed, the game loop runs, and one will notice that there are four possibilities. First, we can be in the username stage, in which we start -- this occurs when username_stage is true. Once we define the username, the global parameter "username" will store this username, and it is also printed to the console as confirmation. This sets the username_stage parameter to false, and it will never again be true. 

Directly after this happens, we have that all the game state parameters are false, so in our game loop, we end up at the home screen -- this is the else condition for all the other game states. On the home screen, we simply have the "Click to Start" text blink, and we display the last score and maximum distance recorded, which begin at 0. When the user clicks from the home screen, all game parameters are reset, marking the beginning of a new iteration of the game. Finally, transition is set to true, meaning that on the next iteration of the while loop, we will fall into the transition stage of the game. In this stage, we simply play an animation that fades the color of the screen, then set transition to false and running to true. Now we are in the running stage of the game. 

Next, I discuss the running stage of the game. In this stage, we store the start time of the current pitch, and compute the current time each iteration/time step. This tells us how long it has been since the last pitch was thrown. If it has been more since the start time than the duration of the current pitch, which is specified by the randomized duration parameter, and the ball has not been hit, then we enter the conditional for this situation. In this conditional, we display strike on the screen, reset all pitch parameters, and increment the number of outs if there have been 3 strikes. If the number of outs equals or exceeds the maximum number, we set running to false, and the game ends -- we are then taken to the leaderboard stage, as leader_stage is set to true, and a click takes us back to the menu screen. The other situation is when the ball is hit -- if the player manages to click the ball's hitbox and have it overlap with the bat's hitbox, the ball is hit, in which case we enter the conditional corresponding to ball_hit = true. In this case, we compute the distance of the hit, which is a function of how close to the center of the ball the player clicked, and we also play a cool little color fading animation if the ball is hit sufficiently well. This also plays another animation of the ball soaring away -- once this animation concludes and we wait the buffer time, we again reset all pitch parameters and throw another pitch.

The design of the game reflects the fact that it is inherently cyclic. There are discrete phases to the game, which are represented by the game state parameters, but within a given game state, the game cycles a given set of actions over and over. In the username screen, we display the clicker and then have it vanish, and repeatedly check if the enter key is pressed. In the running stage, we repeatedly calculate pitches and throw them, checking to see if the ball has been hit and if too much time has elapsed. In the home screen and leaderboard stages, we check to see if the screen has been clicked. Since each discrete game state is cyclic, it makes a lot of sense as a design choice to include the entire game in a while loop, splitting up what should happen based on boolean parameters determining the game state.

Next, I talk about how the random pitch and random ball trajectories are calculated. I wrote a function using the random module to compute a random point in the strike zone, as well as a random point on the screen. To determine a pitch, we choose three control points: a start point (which is fixed in the pitcher's hand), a middle node (which is randomized over the screen), and an endpoint (in the strike zone). Given these three nodes, we let the path of the ball be given by a bezier curve which starts at the start, ends at the end, and has the middle point as its middle node. We compute the place on this bezier curve where the ball is at a certain time with the ball_pos function, which takes in a set of 3 control points and a parameter t which is between 0 and 1 -- the mathematics which I wrote inside this function give a parameterization of the x and y coordinates of the bezier curve, so incrementing t from 0 to 1 allows a point (the ball) to smoothly slide along the bezier curve, throwing a random pitch. There is another function, tweak(t, j), which adjusts the speed of a pitch, and namely whether it speeds up or slows down. This function simply takes in the parameter t, between 0 and 1, and "tweaks" it, plugging into a function that is also between 0 and 1, but has concavity determined by the parameter j, which is between -1 and 1, with positive j parameters causing the ball to start fast and slow down, and negative doing the opposite. The j parameter is randomized along with two of the control points and the duration of the pitch each time a random pitch is calculated.

The remainder of the blitzball file is somewhat trivial. I used an SQL table to store usernames along with the maximum scores and distances associated with these usernames -- this was simply done using the sqlite3 module. Importing fonts, sound effects and sprites was done using the pygame engine, which supports all these things -- I made all the pixel art in the game myself, as well as creating the theme song in Logic Pro X. This concludes the technical description of Blitzball -- I hope you enjoy playing the game!

